package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
)

var (
	path = flag.String("path", "", "Folder path of models to be parsed")
	pkg  = flag.String("pkg", "", "Package name of models")
)

// Print usage message
func Usage() {
	fmt.Fprintf(os.Stderr, "scan-value-generator - A Scan/Value geneartor for String type const which generated by OpenAPI-generator\n\n")
	fmt.Fprintf(os.Stderr, "Usage of Scan/Value generator:\n")
	fmt.Fprintf(os.Stderr, "\tscan-value-generator [flags]\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

// Generate file header for sql operation
func GenFileHeader(pkgName string) *File {

	f := NewFile(pkgName)

	// Write header
	f.HeaderComment("Code generated by scan value generator; DO NOT EDIT")
	f.ImportName("database/sql/driver", "")

	return f

}

func AddSV(f *File, fileName, typeName string, kvPair map[string]string) error {

	f.Commentf("Scan/Value for type \"%s\":", typeName)
	f.Commentf("File locate at %s", fileName)

	f.Func().Params(
		Id("t").Op("*").Id(typeName),
	).Id("Scan").Params(Id("i").Interface()).Error().Block(
		Var().Id("vv").Id(typeName),
		Switch(Id("v").Op(":=").Id("i").Assert(Type())).Block(
			Case(Nil()).Block(
				Return(Nil()),
			),
			Case(Index().Byte()).Block(
				Id("vv").Op("=").Id(typeName).Parens(Id("v")),
			),
			Case(String()).Block(
				Id("vv").Op("=").Id(typeName).Parens(Id("v")),
			),
			Default().Block(
				Return(Qual("fmt", "Errorf").Call(
					Lit("Cannot scan %T into %T"), Id("v"), Id("t"),
				)),
			),
		),

		Line(),

		Switch(Id("vv")).BlockFunc(func(g *Group) {
			for k := range kvPair {
				g.Case(Id(k)).Block()
			}
			g.Default().Block(
				Return(
					Qual("fmt", "Errorf").Call(Lit(fmt.Sprintf("Invalid value of type %s: %%v", typeName)), Id("vv")),
				),
			)
		}),

		Op("*").Id("t").Op("=").Id("vv"),

		Return(Nil()),
	)

	f.Line()

	f.Func().Params(
		Id("t").Id(typeName),
	).Id("Value").Params().Params(Qual("database/sql/driver", "Value"), Error()).Block(
		If(Id("t").Op("==").Lit("")).Block(
			Return(Nil(), Nil()),
		),
		Switch(Id("t")).BlockFunc(func(g *Group) {
			for k := range kvPair {
				g.Case(Id(k)).Block()
			}
			g.Default().Block(
				Return(
					Nil(),
					Qual("fmt", "Errorf").Call(Lit(fmt.Sprintf("Invalid value of type %s: %%v", typeName)), Id("t")),
				),
			)
		}),

		Return(String().Parens(Id("t")), Nil()),
	)

	return nil
}

func main() {

	log.SetFlags(0)
	log.SetPrefix("svgen: ")

	flag.Usage = Usage
	flag.Parse()
	if len(*path) == 0 || len(*pkg) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	folderPath, err := filepath.Abs(*path)
	if err != nil {
		flag.Usage()
		os.Exit(2)
	}

	f := GenFileHeader(*pkg)

	fset := token.NewFileSet()
	pkgs, _ := parser.ParseDir(fset, folderPath, nil, parser.DeclarationErrors)

	for _, pkgNode := range pkgs {
		for _, fileNode := range pkgNode.Files {
			ast.Inspect(fileNode, func(n ast.Node) bool {

				fileName := ""
				typeName := ""
				kvPair := map[string]string{}

				decl, ok := n.(*ast.GenDecl)
				if !ok || decl.Tok != token.CONST {
					return true
				}

				pos := fset.Position(decl.Lparen)
				fileName = pos.Filename

				for _, spec := range decl.Specs {
					// "X TypeA = YYYY". With type and value, skip if untyped
					vspec := spec.(*ast.ValueSpec)
					if vspec.Type == nil {
						continue
					}

					ident, ok := vspec.Type.(*ast.Ident)
					if !ok {
						continue
					}

					if typeName == "" {
						// Check the underlying type
						typeSpec, ok := ident.Obj.Decl.(*ast.TypeSpec)
						if !ok {
							continue
						}

						innerIdent, ok := typeSpec.Type.(*ast.Ident)
						if !ok {
							log.Printf("Maybe not the first element of const %q?", ident.Obj.Name)
							continue
						}

						if innerIdent.Name == "string" {
							typeName = ident.Name
						} else {
							log.Printf("Got const %q with type %q, ignore",
								ident.Name, innerIdent.Name)
							continue
						}
					} else if typeName != ident.Name {
						log.Fatalf("error: got two differnet type const %q & %q in one file",
							typeName, ident.Name)
					}

					// kvPair
					name := vspec.Names[0].Name
					value, ok := vspec.Values[0].(*ast.BasicLit)
					if !ok {
						continue
					}

					if value.Kind != token.STRING {
						log.Fatalf("Something weird happend with const variable %q", name)
					}

					kvPair[name] = value.Value

				}

				err := AddSV(f, fileName, typeName, kvPair)
				if err != nil {
					log.Printf("Generate Scan/Value for type %q failed", typeName)
				}
				return true
			})

		}
	}

	f.Save(fmt.Sprintf("%s/%s_scanner_valuer_generated.go", folderPath, *pkg))

}
